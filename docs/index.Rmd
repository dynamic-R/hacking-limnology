---
title: "Numerical simulation of dynamic systems with R: an introduction"
author: "Thomas Petzoldt and Karline Soetaert"
date: "`r Sys.Date()`"
lang: en
output:
  xaringan::moon_reader:
    css: ["default", "useR-fonts", "tp_xaringan_scrollable.css"]
    seal: false
    lib_dir: libs
    nature:
      beforeInit: "tp_xaringan.js"
      ratio: '16:9'
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
      self_contained: false
      navigation:
        scroll: false
---

class: center, middle, title-slide

background-image: url("img/water-light.jpg")

<!-- Own title slide / -->

# Numerical simulation of dynamic systems with R: an introduction

### Thomas Petzoldt and Karline Soetaert,  `r Sys.Date()`

#### IMPORTANT NOTE

This slide set is work in progress and still at a **very early stage of development**.
It works with **Chrome**, **Firefox** and recent versions of **Edge**.

The name of the repo points to an upcoming workshop about open data in aquatic sciences https://aquaticdatasciopensci.github.io/ in July 2021

For the time being, please consult http://desolve.r-forge.r-project.org


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, fig.width=14, 
                      fig.height=6, dev.args = list(pointsize=20))
library("dplyr")
library("tidyr")
library("kableExtra")
library("DiagrammeR")
library("deSolve")
library("rootSolve")
library("marelac")
mypar <- list(las=1, cex.lab=1.4, cex.axis=1.4, lwd=2)
```

<!-- citations work differently with xaringan compared to @Markdown / -->
```{r, load_refs, include=FALSE, cache=FALSE}
library("RefManageR")
BibOptions(check.entries = FALSE,
           bib.style = "authoryear",
           cite.style = "authoryear",
           style = "markdown",
           dashed = FALSE)
bib <- ReadBib("./bib.bib", check = FALSE)
```

---


## Preface


Dynamical systems are found everywhere, in mathematics, physics, chemistry, engineering and business - ecology and aquatic sciences are no exception.

One common approach to describe such systems is by means of differential equations. Following the ideas of Forrester, differential equations appear quite naturally if we describe changes in a system in terms of growth and decay, which together make up a mass balance. A somewhat bigger challenge is to solve these differential equations - some of us may still remember the challenges of differential calculus in high school courses.

Fortunately, computer algorithms allow to solve even complex differential equation systems numerically. This has opened a world of practical applications to be accessible for anyone that has a basic knowledge in scientific computing, or is willing to acquire this knowledge. R is such a scientific computing language that offers powerful methods to solve differential equations. Moreover, some R-packages are especially designed to also solve spatially variable problems that are often found of importance in aquatic sciences.

The introduction will demonstrate selected examples: growth of organisms, predator-prey interaction, spread of diseases, and transport-reaction problems. The formulation of such models in R can be surprisingly compact and close to the mathematical equations. 

---

### Example 1: Predator-Prey model

![Lotka-Volterra time series](img/predprey_ts.gif)![Lotka-Volterra state diagram](img/predprey_state.gif)

---

### Example 2: Nitrification in a River

.center[
![Nitrification](img/river.gif)
]
---

### Example 3: SIR model - Flatten the curve

<iframe src="https://weblab.hydro.tu-dresden.de/apps/sir-app/" width=1200px, height=600px></iframe>

---

### Example 4: SIR Model in 2D

.center[
![SIR 2D](img/sir2d.gif)
]



---

## Dynamical System


* In mathematics, a system in which a function describes the time dependence of a point in a geometrical space.
* Examples include models that describe the swinging of a clock pendulum, the flow of water in a pipe, and the number of fish each springtime in a lake.
* The state of a dynamical system at a given time is a vector of real numbers, a point in state space. 
* The evolution rule is a function that describes what future states follow from the current state.<sup>[1]</sup>


### Different ways of description

* statistical approach: time series of state variables (pools)
* dynamic approach: description of changes
    * automata in discrete time: IBMs, ABMs, cellular automata
    * equations in discrete time: difference equations
    * equations in continuous time: differential equations (ODEs)

A dynamical system can be described deterministically or stochastically. 

We focus on the **deterministic** description in **continuous** time
with numerically solved differential equations.

[1] Wikipedia, [Dynamical_system](https://en.wikipedia.org/wiki/Dynamical_system)
---

class: scrollable-slide

## Differential Calculus

.pull-left[

$\dot{y} = k \cdot y$

![:scale 50%](img/newton.jpg)

Isaac Newton, 1643 - 1727
]

.pull-right[

$\frac{dy}{dx} = k \cdot y$

![:scale 55%](img/leibniz.jpg)

Gottfried Wilhelm Leibniz, 1646 - 1716


]

---

## Jay W. Forrester: System Dynamics


.pull-left[


![:scale 70%](img/forrester-fig3.png)
]



.pull-right[


![:scale 50%](img/forrester-fig4.png)
]

* thinking in feedback loops
* easy to understand, if we think in pools and changes

From: [Forrester, J.W. (2009) Some Basic Concepts in System Dynamics](https://www.cc.gatech.edu/classes/AY2018/cs8803cc_spring/research_papers/Forrester-SystemDynamics.pdf)

---

## Dynamic systems: how and why?


"Many believe that system dynamics has helped them become skilled at
inventing the future, either by sketching out causal loops on the back of
an envelope, or by assembling equations of cause and effect in a
computer model. Both approaches work." (J.W.F, 1995)


.pull-left[
#### Letâ€™s speak about computers
- continous time $\rightarrow$ differential equations
- discrete time: another interesting story ...

.center[
![:scale 40%](img/rlogo.png)
]
]    

.pull-right[
#### Why numerical integration?
* Not all systems have an analytical solution.
* Numerical solutions allow discrete input.    

"... students can deal with high-order dynamic systems
without ever discovering that their elders consider such to be very difficult."
J.W. Forrester 2009.
]


---

## Import and Export

$${
\frac{dX}{dt} = \mbox{import} - \mbox{export}\\
}$$

```{r diag-im-ex, echo=FALSE, fig.height=4}
grViz("digraph feedback {
         graph [rankdir = 'LR']
           node [shape = box, penwidth=2, fontname = 'Helvetica']
             Matter
           node [shape = octagon, penwidth=0.5, style='rounded', fixedsize=25, fontsize=8]
             Source Sink
           node [shape = none, fontsize=10]
             import export
           edge [penwidth=1.5]
             Source -> import -> Matter -> export -> Sink
         
}")
```



---

## Exponential Growth

$${\frac{dN}{dt} = \mbox{birth} - \mbox{death}\\
\frac{dN}{dt} = \mbox{birthhrate} \cdot N - \mbox{deathrate}\cdot N\\
\frac{dN}{dt} = b \cdot N - d \cdot N = (b-d) \cdot N = r \cdot N\\
}$$
```{r echo=FALSE, fig.height=4}
grViz("digraph feedback {
         graph [rankdir = 'LR']
           node [shape = box, penwidth=2, fontname = 'Helvetica']
             Population
           node [shape = octagon, penwidth=0.5, style='rounded', fixedsize=25, fontsize=8]
             Source Sink
           node [shape = none, fontsize=10]
             birth death
           edge [penwidth=1.5]
             Source -> birth -> Population -> death -> Sink
           edge [penwidth=0.7, tailport = 'n', headport = 'n', constraint = false, color=tomato]
             Population -> birth 
             Population -> death
}")
```


---

## Analytical Integration



.pull-left[
```{r expgrowth, echo=FALSE, fig.height=4, fig.width=10}
par(mar=c(4, 5, 0, 1)+.1, las=1)
r    <- 0.5
N0   <- 10
dt   <- 0.1
time <- seq(0, 10, dt)
N <- N0 * exp(r * time)
plot(time, N, type="l", ylim=c(0, 1500))
```
```r
r    <- 0.5
N0   <- 10
dt   <- 0.1
time <- seq(0, 10, dt)

N <- N0 * exp(r * time)
plot(time, N, type="l")
```
]

.pull-right[
\begin{align}
\frac{dN}{dt} &= r\cdot N\\
\int_0^t \frac{dN}{dt} &= \int_0^t r\cdot N\\
\int_0^t \frac{1}{N} dN &= \int_0^t r dt\\
\ln(N) &= rt + c\\
N_t &= N_0 e^{rt}\\
\end{align}

* Integral calculus = "Gold Standard" ...
* ... but not always possible
]

---

## Numerical Integration with the Euler Method


.pull-left[

```{r expgrowth-euler, echo=FALSE, fig.height=4, fig.width=10}
par(mar=c(4, 5, 0, 1)+.1, las=1)
N <- numeric(length(time))

N[1] <- N0
for (i in 2:length(time)) {
  N[i] <- N[i-1] + r * N[i-1] * dt
}
plot(time, N, type = "l", lty="dashed", col="red", ylim=c(0, 1500))
N <- N0 * exp(r * time)
lines(time, N, lty="solid")
```


```{r echo=TRUE, eval=FALSE}
N <- numeric(length(time))

N[1] <- N0
for (i in 2:length(time)) {
  N[i] <- N[i-1] + r * N[i-1] * dt
}
plot(time, N, type = "l", 
     col = "red", lty = "dashed")
```
]

.pull-right[
\begin{align}
\frac{dN}{dt} &= r\cdot N\\
\frac{\Delta N}{\Delta t} &= r\cdot N\\
N_t &= N_{t-1} + r\cdot N_{t-1}
\end{align}

* differential equation $\rightarrow$ difference equation
* approximation with discrete time step
* easy, but integration error
]

---

### Numerical Integration with deSolve: the Simple Way

.pull-left[
#### Logistic growth

$\frac{dN}{dt} = rN(1-N/K)$

#### Model formulation close to mathematical notation

```{r, ode-naive, eval=FALSE, echo=TRUE}
library("deSolve")
model <- function (time, y, parms) {
  with(as.list(c(y, parms)), {
  {{dN <- r * N * (1 - N / K)}}
    list(c(dN))
  })
}
y0 <- c(N = 0.1)
parms <- c(r = 0.1, K = 10)
times <- seq(0, 100, 1)
```
]

.pull-right[
#### Solve with `ode`

```{r, echo=TRUE, eval=FALSE}
out <- ode(y0, times, model, parms)
plot(out)
```


```{r, ode-naive2, eval=TRUE, echo=FALSE, fig.width=10, fig.height=6}
par(las=1, mar=c(5,5,1.5,1)+.1)
library("deSolve")
model <- function (time, y, parms) {
  with(as.list(c(y, parms)), {
    dN <- r * N * (1 - N / K)
    list(c(dN))
  })
}
y0 <- c(N = 0.1)
parms <- c(r = 0.1, K = 10)
times <- seq(0, 100, 1)
out <- ode(y0, times, model, parms)
plot(out)
```

* better performance, reduced integration error
]

---
## What is deSolve?

.pull-left[ 

#### An **R package** to solve differential equations

* numerical simulation of **initial value problems**
* ODE, PDE, DAE, DDE
* popular *industry class solvers* from ODEPACK $^1$
* `+` classical Euler and Runge-Kutta solvers
* convenience tools (e.g. `plot`, forcings, events) 
* extensive documentation, e.g.
  `r Citep(bib, "deSolve_jss")`
]

.pull-right[

#### Part of an "Ecosystem" for dynamical simulations
* packages: rootSolve, bvpSolve, FME, reacTran, ...
* books, websites, [StackOverflow](https://stackoverflow.com/search?tab=newest&q=%5br%5d%20desolve?ode)

#### More:
* See [CRAN Task View](https://cran.r-project.org/web/views/DifferentialEquations.html) for related packages
]

$^1$ Thanks to the great authors (ctb=contributors) of the original algorithms who made their code publicly available:

Peter N. Brown [ctb] (files ddaspk.f, dvode.f, zvode.f), George D. Byrne [ctb] (files dvode.f, zvode.f), Ernst Hairer [ctb] (files radau5.f, radau5a), Alan C. Hindmarsh [ctb] (files ddaspk.f, dlsode.f, dvode.f, zvode.f, opdkmain.f, opdka1.f), Cleve Moler [ctb] (file dlinpck.f), Linda R. Petzold [ctb] (files ddaspk.f, dlsoda.f), Youcef Saad [ctb] (file dsparsk.f), Clement W. Ulrich [ctb] (file ddaspk.f)

---
## What is `ode`?

#### `ode`
* top-level function to call one of the solvers
* default: `lsoda`
* Livermore solver for Ordinary Differential Equations, automatic

#### `lsoda`, `adams`, `bdf`, `vode`, ...?

* stiff systems: `bdf`: tries hard to solve the system
* sometimes, `adams` may be faster for simple problems 
* default `lsoda` switches automatically between `bdf`and `adams`

#### `euler`, `rk4`, `ode45`, ...

* for specific problems

#### `ode.1D`, ... `ode.3D`, ... `dde` 

* see [docs](cran.r-project.org/package=deSolve/)


---
## Automatic Step Size

.pull-left[
#### External and internal step size

* user specifies tolerances `atol`, `rtol` = 1e-6
* solver **adapts** internal step size to meet precision
* results returned at pre-specified **external** time points


#### Fixed-step solvers

* `euler`, `rk2`, `rk4`
* problem: either not precise enough or too much work
    * danger of instability
    * optimum time step can vary over time
    * stiff systems: some states change faster than others
* `rk4` was very popular, as it is very easy to implement
* use only if you know why 

]

.pull-right[

```r
out <- ode(y0, 
*  times = 1:10, # external time steps
  model, 
  parms, 
  atol = 1e-6, # absolute tolerance
  rtol = 1e-6  # relative tolerance
)
```
]


---
## Resource Limited Growth

#### Two state variables

* Nutrients, Algae
* feedback
* functional response (e.g. Holling, Monod, ...)



```{r diag-resource-limited, echo=FALSE, eval=TRUE, fig.height=2}
library(DiagrammeR)

grViz("digraph feedback {
         graph [rankdir = 'LR']
           node [shape = box, penwidth=2, fontname = 'Helvetica']
             Nutrient, Algae
           node [shape = none, fontsize=10]
             growth
           edge [penwidth=1.5]
             Nutrient -> growth -> Algae 
           edge [penwidth=0.7, tailport = 'n', headport = 'n', constraint = false, color=tomato]
             Algae -> growth 
}")
```


---


### System of equations

```{r diag-resource-limited, echo=FALSE, eval=TRUE, fig.height=2}
```

----

\begin{align}
\frac{d\mbox{Algae}}{dt} &=       & &r \cdot f(\mbox{Nutrients}) \cdot \mbox{Algae}\\
\\
\frac{d\mbox{Nutrients}}{dt} &=   &- & r \cdot f(\mbox{Nutrients}) \cdot  \mbox{Algae} \cdot \frac{1}{Y} 
\end{align}

with:

$$
f(\mbox{Nutrients}) =  \text{functional response, e.g. Holling I, II, III}
$$


---

## Resource Limited Growth

#### The Model

```{r, resource-limited, echo=TRUE, eval=TRUE}
model <- function (time, y, parms) {
  with(as.list(c(y, parms)), {
    f <- P/(kP + P)
    dAlg <- r * f * Alg
    dP   <- - r * 1/Y * f * Alg
    list(c(dAlg, dP))
  })
}
y <- c(Alg = 0.1, P = 0.2) # in mg/L
parms <- c(r = 0.1, kP = 5e-3, Y = 41) # Y = C:P mass ratio
```

#### Where do parameters come from?

* $r$, $k_P$ derived from lab experiments
* $Y$ first guess from stoichiometry

```{r, , echo=TRUE, eval=TRUE}
library("marelac")
redfield(1, species="P", method="mass")
```

#### Simulate Model


```{r , echo=TRUE, eval=TRUE, fig.height=6}
out <- ode(y, times, model, parms)
plot(out, las=1)
```

#### Compare Scenarios

```{r , echo=TRUE, eval=TRUE, fig.height=6}
out1 <- ode(y, times, model, parms =  c(r = 0.2, kP = 5e-3, Y = 41))
out2 <- ode(y, times, model, parms =  c(r = 0.1, kP = 1e-2, Y = 50))

plot(out1, out2, las=1)
legend("topright", legend=c("Scenario 1", "Scenario 2"), lty=1:2, col=1:2)
```



---

## SIR and the Covid 19 Pandemic


* similar to resource-limited growth
* show atol, rtol and rescaling of problems


---

## A standard SIR model

```{r diag-sir, echo=FALSE, fig.height=4}
grViz("digraph feedback {
         graph [rankdir = 'LR']
           node [shape = box, penwidth=2, fontname = 'Helvetica', style='filled', color='dodgerblue']
             S, I, R
           node [shape = none, fontsize=10, style='']
             infection, recovery, mortality
            node [shape = octagon, penwidth=0.5, style='rounded', fixedsize=25, fontsize=8]
             X
           edge [penwidth=1.5]
             S -> infection -> I
             I -> recovery -> R
             I -> mortality
             mortality -> X
}")
```

#### Total population is subdivided into 3 subpopulations

* $S$: susceptible, $I$: infected, $R$: recovered

This is the general scheme from which different modifications can be derived,
e.g. an additional state variable $E$ (SEIR model) of exposed, or of deceased individuals $X$ (SIRX). It is also possible to consider multiple groups of $S$, $I$, $R$, their spatial
distribution or influence of stochasticity.

---

### Equations describing spread of the disease:


\begin{align}
\frac{dS}{dt} &= -Infection\\
\frac{dI}{dt} &= Infection - Recovery - Mortality\\
\frac{dR}{dt} &= Recovery
\end{align}

where 

\begin{align}
Infection &= b \cdot I \cdot S\\
Recovery  &= g \cdot I\\
Mortality &= m \cdot I
\end{align}

| Name      | Value      | Description         | Unit                        |
| --------- | ---------- | ------------------- | --------------------------- |
| b         | 0.00000002 | infection parameter | $\mathrm{ind^{-1}~d^{-1}}$ |
| g         | 0.07       | recovery parameter  | $\mathrm{d^{-1}}$           |
| m         | 0.007      | mortality parameter | $\mathrm{d^{-1}}$           |


---

### Code

```{r SIR-solution, echo=TRUE, fig.width=16, fig.height=6}
SIR <- function(t, state, parameters) {
  with (as.list(c(state, parameters)), {

    Infection <- b * S * I
    Recovery  <- g * I
    Mortality <- m * I
    
    dSdt      <- -Infection 
    dIdt      <-  Infection - Recovery - Mortality
    dRdt      <-  Recovery

    list(c(dSdt, dIdt, dRdt), # the time derivatives
                 Population = S+I+R)    # extra output variable
  }) 
}

y0 <- c(S = 11500000 - 1000, I = 1000, R = 0)

parms <- c(
  b = 0.00000002,    # [1/ind/d], infection parameter 
  g = 0.07,          # [1/d],     recovery rate of infected individuals
  m = 0.007          # [1/d],     mortality rate of infected individuals
)


times <- seq(from=0, to=365, by=1)   # time sequence, in days
out   <- ode(y = y0, times=times, func=SIR, parms=parms)
plot(out, las=1, mfrow=c(1,4))
```




---

## External Interventions

* Let's assume society implements social distancing **after** realizing exponential growth
* implementation of forcings

```{r SIR-distancing, echo=TRUE, fig.width=16, fig.height=6}
SIR_distancing <- function(t, state, parameters) {
  with (as.list(c(state, parameters)), {
    rho <- f_rho(t)
    Infection <- rho * b * S * I
    Recovery  <- g * I
    Mortality <- m * I
    
    dSdt      <- -Infection 
    dIdt      <-  Infection - Recovery - Mortality
    dRdt      <-  Recovery

    list(c(dSdt, dIdt, dRdt),      # the time derivatives
                 Population = S+I+R)            # extra output variable
  }) 
}

f_rho <- approxfun(x=c(0, 50, 51, 365), y=c(1, 1, 0.5, 0.5), rule=2)

y0 <- c(S = 11500000 - 1000, I = 1000, R = 0)

parms <- c(
  b = 0.00000002,    # [1/ind/d], infection parameter 
  g = 0.07,          # [1/d],     recovery rate of infected individuals
  m = 0.007          # [1/d],     mortality rate of infected individuals
)


times <- seq(from=0, to=365, by=1)   # time sequence, in days
out2   <- ode(y = y0, times=times, func=SIR_distancing, parms=parms)
plot(out, out2, las=1, which=c("S", "I", "R"), mfrow=c(1,3))
```




---

## Back to Lake Modelling: The Chemostat


* inflow and outflow
* numerical solution
* equilibrium
* rootSolve and analytical solution of equilibrium

---

## Chemostat: Equations

\begin{align}
\frac{dAlg}{dt}  & = \mu \cdot Alg - D \cdot Alg\\
\frac{dP}{dt}    & =  D \cdot (P_0 - P) - 1/Y \cdot \mu \cdot Alg\\
\\
\text{with:}\\
\mu   & = \mu_{max} \cdot \frac{P}{kp + P}  \qquad\text{(Monod equation)}\\
\end{align}

**Todo: add drawing with symbols here**

---

## The Chemostat Code


```{r Chemostat-dynamic, echo=TRUE, fig.height=6, dev.args=list(pointsize=20)}
library("deSolve")
library("rootSolve")

chemostat <- function(time, init, parms) {
  with(as.list(c(init, parms)), {
    mu   <- mumax * P/(kp + P)  # Monod equation
    dAlg <- mu * Alg - D * Alg
    dP   <-  D *(P0 - P) - 1/Y * mu * Alg
    list(c(dAlg, dP), mu=mu)
   })
}
parms <- c(
  mumax = 0.5,    # 1/d
  kp    = 0.01,   # half saturation constant (mg/L)
  Y     = 41,     # yield coefficient (stoichiometric C:P ratio)
  D     = 0.1,    # 1/d
  P0    = 0.05    # P in inflow (mg/L)
)
times <- seq(0, 40, 0.1)  # (d)
init  <- c(Alg=0.01, P=0.05) # Phytoplankton C and Phosphorus P (mg/L)

## =============================================================================
## Dynamic simulation
## =============================================================================
out <- ode(init, times, chemostat, parms)
plot(out, mfrow=c(1, 3), las=1)
```

---

### Equilibrium

#### Steady state solution

```{r chemostat-equilibrium, echo=TRUE, fig.height=12}
state <- data.frame(
  D = seq(0, 0.6, length.out = 100),
  X = 0,
  S = 0
)

for (i in 1:nrow(state)) {
  parms["D"] <- state$D[i]
  times <- c(0, Inf)
  out <- runsteady(init, times, chemostat, parms)
  state[i, 2:3] <- out$y
}

par(mfrow = c(3, 1))
plot(S ~ D, data = state, type = "l")
plot(X ~ D, data = state, type = "l")
plot(S * X ~ D, data = state, type = "l")
```


**Note:** this can also be solved analytically.


---

## Interaction Between Populations

### Lotka-Volterra's Predator and Prey

```{r diag-LV, echo=FALSE, fig.height=4}
grViz("digraph lotka {
         graph [rankdir = 'LR']
           node [shape = box, penwidth=2, fontname = 'Helvetica']
             Predator, Prey
           node [shape = octagon, penwidth=0.5, style='rounded', fixedsize=25, fontsize=8]
             Source Sink
           node [shape = none, fontsize=10]
             growth death grazing
           edge [penwidth=1.5]
             Source -> growth -> Prey -> grazing -> Predator -> death -> Sink
           edge [penwidth=0.7, tailport = 'n', headport = 'n', constraint = false, color=tomato]
             Prey -> growth
             Predator -> grazing
           edge [penwidth=0.7, tailport = 's', headport = 's', constraint = false, color=tomato]
             Prey -> grazing
             Predator -> death

}")
```

* state diagram, cycles
* damped cycle if we introduce a Monod term




---

### Lotka Voltera Model

```{r diag-LV, echo=FALSE, fig.height=2}
```

\begin{align}
\frac{dX}{dt} &= \mbox{Growth} - \mbox{Grazing} \qquad & \mbox{(Prey)}\\
\\
\frac{dY}{dt} &= g \cdot \mbox{Grazing} - \mbox{Mortality}  \qquad & \mbox{(Predator)}
\end{align}

With:

\begin{align}
\mbox{Growth}    & = a \cdot X & \qquad \text{(exponential growth)}\\
\mbox{Grazing}   & = b \cdot X \cdot Y & \qquad \text{(interaction)}\\
\mbox{Mortalily} & = -e \cdot Y & \qquad \text{(exponential decay)}
\end{align}

---
```{css}
.remark-slide-number {
    display: none;
}
```

### Lotka-Volterra Model: Implementation

```{r, LV-basic, echo=TRUE, fig.height=4}
require(deSolve)   
y0      <- c(X=300, Y=10)            # state variable initial conditions
parms   <- c(a=0.05, K=500, b=0.0002, g=0.8, e=0.03)  # parameter values

LV <- function(t, state, parameters) { 
  with (as.list(c(state, parameters)), {
    Growth     <- a*X
    Grazing    <- b*X*Y
    Mortality  <- e*Y
    dXdt <- Growth - Grazing
    dYdt <- g * Grazing - Mortality
    return (list(c(dXdt, dYdt),  # vector of derivatives
                 sum = X+Y))     # output variable
  })
}
times <- 1:1000
out   <- ode(y = y0, func = LV, times = times, parms = parms)
plot(out, mfrow = c(1, 3), las=1)
```


---

## Efficient Model Formulation in Matrix Style

#### Two preys and two preadors $\rightarrow$ 4 equations
```{r, echo=TRUE}
model <- function(t, n, parms) {
  with(as.list(c(n, parms)), {
    dn1 <- r1 * n1 - a13 * n1 * n3
    dn2 <- r2 * n2 - a24 * n2 * n4
    dn3 <- a13 * n1 * n3 - r3 * n3
    dn4 <- a24 * n2 * n4 - r4 * n4
    return(list(c(dn1, dn2, dn3, dn4)))
  })
}

times <- seq(from=0, to=500, by = 0.1)
n0    <- c(n1=1, n2=1, n3=2, n4=2)
parms <- c(r1 = 0.1, r2=0.1, r3=0.1, r4=0.1,  # net growth = birth - death
          a13=0.2, a24 = 0.1                  # interaction
)

out <- ode(n0, times, model, parms)
```

#### Matrix formulation: appears as one single equation

```{r, echo=TRUE, fig.height=8}
model <- function(t, n, parms) {
  with(parms, {
    {{dn <- r * n  + n * (A %*% n)}}
    return(list(dn))
  })
}

parms <- list(
  r = c(r1 = 0.1, r2 = 0.1, r3 = -0.1, r4 = -0.1),
  ## pairwise interactions:
  A = matrix(c(0.0, 0.0, -0.2,  0.0,    # prey 1
               0.0, 0.0,  0.0, -0.1,    # prey 2
               0.2, 0.0,  0.0,  0.0,    # predator 1; eats prey 1
               0.0, 0.1,  0.0,  0.0),   # predator 2; eats prey 2
               nrow = 4, ncol = 4, byrow = TRUE)
)

out <- ode(n0, times, model, parms)
plot(out, las=1)
```




---

## PDE's in 1D: Transport in a River


* package ReacTran
* uses also matrix formulation
* plot3D example

---

## Outlook


* some bigger applications
* rodeo package
* shiny

---

## Appendices


Things that should be mentioned somewhere, but not yet in the introductory
lecture

* Solver functions in deSolve
* C and Fortran interface
* Karline's books
* Online resources: R-Forge, CRAN-Taskview, publications



---

## Copyright


This resource was created by [tpetzoldt](github.com/tpetzoldt) and 
[karlines](https://github.com/karlines). It is provided 
as is without warranty.

---

## Bibliography


```{r refs, echo=FALSE, results="asis"}
PrintBibliography(bib)
```

